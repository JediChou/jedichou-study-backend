#### 3.1.1.1 泛型
* 符号表
* 键的有序性
* Comparable的对象

#### 3.1.1.2 重复的键
* 关联数组的抽象形式

#### 3.1.1.3 空键
#### 3.1.1.4 空值
#### 3.1.1.5 删除操作
* 延迟删除, 即时删除
* 防御性代码

#### 3.1.1.6 便捷方法
* void delete(Key key)
* boolean contains(key)
* boolean isEmpty()

#### 3.1.1.7 迭代
* iterator(), hasNext(), next()
* keys(), Interable<Key>

#### 3.1.1.8 键的等价性
* 对象等价性的概念, equals()

### 3.1.2 有序符号表
* Comparable object, a.compareTo(b)
* Comparable interface -> put(), get()
* table 3.1.4 一种有序的泛型符号表的API
  - public class ST<Key extends Compareable<key>, Value>
  - ST()
  - void put(Key key, Value val)
  - Value get(Key key)
  - void delete(Key key)
  - boolean contains(Key key)
  - boolean isEmpty()
  - int size()
  - Key min()
  - Key max()
  - Key floor(Key key)
  - Key ceiling(Key key)
  - int rank(Key key)
  - Key select(int k)
  - void deleteMin()
  - void deleteMax()
  - int size(Key lo, Key hi)
  - Iterable<Key> keys(Key lo , Key hi)
  - Iterable<Key> keys()
  
#### 3.1.2.1 最大键和最小键
* IndexMinPQ()

#### 3.1.2.2 向下取整和向上取整
* floor, ceiling

#### 3.1.2.3 排名和选择
* rank, select
* i == rank(select(i))
* key == select(rank(key))

#### 3.1.2.4 范围查找
* size(), keys()

#### 3.1.2.5 例外情况
#### 3.1.2.6 便捷方法
#### 3.1.2.7 键的等价性
#### 3.1.2.8 成本模型
  
### 3.1.3 用例举例
#### 3.1.3.1 行为测试用例
* Figure 3.1.1

#### 3.1.3.2 性能测试用例
* 特性
  - 混合使用查找和插入的操作
  - 大量的不同键
  - 查找操作比插入操作多得多
  - 虽然不可预测，但查找和插入操作的使用模式并非随机
  
### 3.1.4 无序链表的顺序查找
* 算法3.1(SequentialSearchST)
* 命题A
* 随机命中

### 3.1.5 有序数组中的二分查找
* 算法3.2(BinarySearchST)

#### 3.1.5.1 二分查找
* Figure 递归的二分查找
* 算法3.2(续1)
* 算法3.2(续2)

#### 3.1.5.2 其他操作

### 3.1.6 对二分查找的分析
* 二分查找很快
* 命题B（续）

### 3.1.7 预览
* 二分查找无法处理Leipzig Corpora数据库
* 二叉查找树
* 优缺点

## 3.2 二叉查找树
* 结点、链接
* 根节点、父节点
* 定义

### 3.2.1 基本实现
#### 3.2.1.1 数据表示
#### 3.2.1.2 查找
* 算法3.3 基于二叉查找树的符号表
* 算法3.3（续1） 二叉查找树的查找和排序方法的实现

#### 3.2.1.3 插入
#### 3.2.1.4 递归
* 图3.2.6 使用二叉查找树的标准索引用例的轨迹

### 3.2.2 分析
* 图3.2.7 二叉查找树的可能形状
* 命题C

### 3.2.3 有序性相关的方法与删除操作

#### 3.2.3.1 最大键和最小键
#### 3.2.3.2 向上取整和向下取整
#### 3.2.3.3 选择操作
* 算法3.3（续2）

#### 3.2.3.4 排名
* 算法3.3（续3）

#### 3.2.3.5 删除最大键和删除最小键
#### 3.2.3.6 删除操作
* 算法3.3（续4）

#### 3.2.3.7 范围查找
* 算法3.3（续5）

#### 3.2.3.8 性能分析
* 命题E
* 表3.2.2

## 3.3 平衡查找树
### 3.3.1 2-3查找树
* 定义

#### 3.3.1.1 查找
#### 3.3.1.2 向2-节点中插入新键
#### 3.3.1.3 向一颗只含有一个3-节点的树中插入新键
#### 3.3.1.4 向一个父节点为2-结点的3-结点中插入新键
#### 3.3.1.5 向一个父结点为3-结点的3-结点中插入新键
#### 3.3.1.6 分解根节点
#### 3.3.1.7 局部变换
#### 3.3.1.8 全局性质
* 命题F

### 3.3.2 红黑二叉查找树
#### 3.3.2.1 替换3-结点
#### 3.3.2.2 一种等价的定义
#### 3.3.2.3 一一对应
#### 3.3.2.4 颜色表示
#### 3.3.2.5 旋转
#### 3.3.2.6 在旋转后重置父结点的链接
#### 3.3.2.7 向2-结点中插入新键
#### 3.3.2.8 向树底部的2-结点插入新键
#### 3.3.2.9 向一棵双键树（即一个3-结点）中插入新键
#### 3.3.2.10 颜色转换
#### 3.3.2.11 根节点总是黑色
#### 3.3.2.12 向树底部的3-结点插入新键
#### 3.3.2.13 将红链接在树中向上传递

### 3.3.3 实现
* 算法3.4 红黑树的插入算法

### 3.3.4 删除操作
#### 3.3.4.1 
#### 3.4.4.2
#### 3.4.4.3

### 3.3.5
* 基于红黑树的符号表实现都能保证操作的运行时间为对数级别

#### 3.3.5.1
* 命题G
* 命题H

#### 3.3.5.2

## 3.4
* 散列
* 拉链发和线性探测法

### 3.4.1 散列函数
#### 3.4.1.1
#### 3.4.1.2
#### 3.4.1.3
#### 3.4.1.4
#### 3.4.1.5
#### 3.4.1.6
#### 3.4.1.7
#### 3.4.1.8
#### 3.4.1.9

### 3.4.2
* 算法3.5 基于拉链法的散列表
* 算法K
* 性质L

#### 3.4.2.1
#### 3.4.2.2
#### 3.4.2.3

### 3.4.3
* 算法3.6 基于线性探测的符号表

#### 3.4.3.1 删除操作
#### 3.4.3.2
#### 3.4.3.3

### 3.4.4
* LinearProbingHashST

#### 3.4.4.1 拉链法
#### 3.4.4.2 均摊分析
* 命题N

### 3.4.5

## 3.5
### 3.5.1
#### 3.5.1.1
#### 3.5.1.2
#### 3.5.1.3
### 3.5.2
#### 3.5.2.1 dedup
#### 3.5.2.2

### 3.5.3
* 电话黄页
* 字典
* 账户信息
* 基因组学
* 实验数据
* 编译器
* 文件系统
* 互联网DNS
* 字典查找

### 3.5.4 索引类用例
* 商业交易
* 网络搜索
* 电影和演员
* 反向索引
  - 互联网电影数据库
  - 图书索引
  - 编译器
  - 文件搜索
  - 基因组学

### 3.5.5
* 矩阵和向量相乘的标准实现

# 第4章 图
* 地图、网页信息、电路、任务调度、商业交易、配对
* 计算机网络、软件、社交网络
* 无向图、有向图、加权图、加权有向图

## 4.1 无向图
* 定义

### 4.1.1 术语表
### 4.1.2
* Graph
  - Graph(int v)
  - Graph(In in)
  - int V()
  - int E()
  - void addEdge(int v, int w)
  - Iterable<Integer> adj(int v)
  - String toString()
  
#### 4.1.2.1
#### 4.1.2.2
#### 4.1.2.3

### 4.1.3
#### 4.1.3.1
#### 4.1.3.2
#### 4.1.3.3
#### 4.1.3.4
#### 4.1.3.5
* 连通性
* 单点路径

### 4.1.4
#### 4.1.4.1
#### 4.1.4.2

### 4.1.5
* 算法4.2

### 4.1.6 连通分量
#### 4.1.6.1 实现
* 算法4.3

#### 4.1.6.2 union-find
### 4.1.7
#### 4.1.7.1
#### 4.1.7.2
#### 4.1.7.3
#### 4.1.7.4
* 间隔的度数
### 4.1.8

## 4.2
### 4.2.1
### 4.2.2
#### 4.2.2.1
#### 4.2.2.2
#### 4.2.2.3
#### 4.2.2.4
### 4.2.3
* 命题D
* 算法4.4

#### 4.2.3.1
#### 4.2.3.2
### 4.2.4
#### 4.2.4.1
* 优先级限制
* 拓扑排序
#### 4.2.4.2
* 有向环检测
* 定义
* 命题E
* 命题4.5
* 命题F
* 命题G

### 4.2.5 有向图中的强连通性
* 定义
#### 4.2.5.1
#### 4.2.5.2
#### 4.2.5.3 Kosaraju algorithms
* 命题H
* 命题I

#### 4.2.5.4 再谈可达性
* 定义
### 4.2.6 总结

## 4.3 最小生成树
### 4.3.1 原理
#### 4.3.1.1
* 定义
* 命题J

#### 4.3.1.2 贪心算法
### 4.3.2
#### 4.3.2.1
#### 4.3.2.2
#### 4.3.2.3

### 4.3.3
#### 4.3.3.1
#### 4.3.3.2

### 4.3.4
* 命题L

#### 4.3.4.1
#### 4.3.4.2
#### 4.3.4.3 
* 命题M

### 4.3.5
* 算法4.7
* 命题N

### 4.3.6
* 命题N
* 算法4.8 最小生成树的Kruskal算法

### 4.3.7
#### 4.3.7.1
#### 4.3.7.2

## 4.4
* 定义

### 4.4.1 最短路径的性质
### 4.4.2
#### 4.4.2.1
#### 4.4.2.2
#### 4.4.2.3
#### 4.4.2.4
#### 4.4.2.5
#### 4.4.2.6

### 4.4.3
#### 4.4.3.1
* 命题P

#### 4.4.3.2
#### 4.4.3.3
* 命题Q

### 4.4.4 Dijkstra算法
* 命题R

#### 4.4.4.1
#### 4.4.4.2
* 命题R(续)

#### 4.4.4.3
### 4.4.5
* 命题S

#### 4.4.5.1
* 命题T
#### 4.4.5.2
#### 4.4.5.3
* 命题V

### 4.4.6
#### 4.4.6.1
#### 4.4.6.2
#### 4.4.6.3
* 定义
* 命题W
#### 4.4.6.4
* 命题X
* 命题W(续)
#### 4.4.6.5
#### 4.4.6.6
* 算法4.11
#### 4.4.6.7
#### 4.4.6.8
#### 4.4.6.9

### 4.4.7

# 第5章 字符串
* 信息处理
* 基因组学
* 通信系统
* 编程系统

### 5.0.1
### 5.0.2

## 5.1
### 5.1.1
#### 5.1.1.1
#### 5.1.1.2
#### 5.1.1.3
#### 5.1.1.4
* 命题A

### 5.1.2
* 算法5.1 低位优先的字符串排序
* 命题B

### 5.1.3
#### 5.1.3.1
#### 5.1.3.2
* 算法5.2 高位优先的字符串排序

#### 5.1.3.3 小型子数组
#### 5.1.3.4
#### 5.1.3.5
#### 5.1.3.6
#### 5.1.3.7
* 随机输入
* 非随机输入
* 最坏情况
* 命题C
* 命题D

### 5.1.4 三向字符串快速排序
#### 5.1.4.1
#### 5.1.4.2
#### 5.1.4.3
#### 5.1.4.4
#### 5.1.4.5

### 5.1.5

## 5.2 单词查找树
### 5.2.1
#### 5.2.1.1
#### 5.2.1.2
#### 5.2.1.3
#### 5.2.1.4
#### 5.2.1.5
* 算法5.4 基于单词查找树的符号表

#### 5.2.1.6 查找所有键
#### 5.2.1.7 通配符匹配
#### 5.2.1.8
#### 5.2.1.9
#### 5.2.1.10

### 5.2.2
* 命题F

#### 5.2.2.1
* 命题G

#### 5.2.2.2
* 命题H

#### 5.2.2.3
* 命题I

#### 5.2.2.4
### 5.2.3
* 算法5.5 基于三向单词查找树的符号表

### 5.2.4
#### 5.2.4.1
* 命题J

#### 5.2.4.2
* 命题K

#### 5.2.4.3
#### 5.2.4.4
#### 5.2.4.5
#### 5.2.4.6
#### 5.2.4.7
* 命题L

### 5.2.5

## 5.3
### 5.3.1
### 5.3.2
* 命题M

### 5.3.3
#### 5.3.3.1
#### 5.3.3.2 KMP查找算法
#### 5.3.3.3 DFA模拟
#### 5.3.3.4 构造DFA
* 算法5.6 Knuth-Morris-Pratt字符串查找算法

### 5.3.4 Boyer-Moore字符串查找算法
#### 5.3.4.1
#### 5.3.4.2
#### 5.3.4.3
* 命题O
* 算法5.7 Boyer-Moore字符串匹配算法

### 5.3.5 Rabin-Karp
#### 5.3.5.1
#### 5.3.5.2
#### 5.3.5.3
#### 5.3.5.4
#### 5.3.5.5
* 算法5.8
* 命题P

### 5.3.6 总结

## 5.4 正则表达式
### 5.4.1
#### 5.4.1.1
#### 5.4.1.2
#### 5.4.1.3
#### 5.4.1.4
* 定义、定义（续）

### 5.4.2 缩略写法
#### 5.4.2.1
#### 5.4.2.2
#### 5.4.2.3

### 5.4.3
#### 5.4.3.1
#### 5.4.3.2
#### 5.4.3.3 程序员的工具箱
#### 5.4.3.4 基因组
#### 5.4.3.5 搜索
#### 5.4.3.6 正则表达式的可能性
#### 5.4.3.7 局限

### 5.4.4 非确定有限状态自动机
### 5.4.5 模拟NFA的运行
#### 5.4.5.1
#### 5.4.5.2
* 命题Q

### 5.4.6 构造正则表达式对应的NFA
#### 5.4.6.1
#### 5.4.6.2
#### 5.4.6.3
#### 5.4.6.4
* 命题R

## 5.5 数据压缩
### 5.5.1 游戏规则
### 5.5.2 读写二进制数据
#### 5.5.2.1
#### 5.5.2.2
#### 5.5.2.3
#### 5.5.2.4
### 5.5.3 局限
#### 5.5.3.1
* 命题S

#### 5.5.3.2
### 5.5.4 热身运行：基因组
#### 5.5.4.1
#### 5.5.4.2
#### 5.5.4.3

### 5.5.5 游程编码
#### 5.5.5.1
#### 5.5.5.2
#### 5.5.5.3

### 5.5.6 霍夫曼压缩
#### 5.5.6.1
#### 5.5.6.2
#### 5.5.6.3
#### 5.5.6.4
#### 5.5.6.5
#### 5.5.6.6
#### 5.5.6.7
#### 5.5.6.8
* 命题t
* 命题U
#### 5.5.6.9
#### 5.5.6.10
* 算法5.10
#### 5.5.6.11
#### 5.5.6.12
#### 5.5.6.13
#### 5.5.6.14
* 算法5.11
#### 5.5.6.15
#### 5.5.6.16
* 算法5.11（续）

# 第6章 背景
* 商业应用、科学计算、工程学、运筹学

### 6.0.1 事件驱动模拟
#### 6.0.1.1 刚性球体模型
#### 6.0.1.2 时间驱动模型
#### 6.0.1.3 事件驱动模型
#### 6.0.1.4 碰撞预测
#### 6.0.1.5 碰撞计算
#### 6.0.1.6 排除无效事件
#### 6.0.1.7 粒子
#### 6.0.1.8 事件
#### 6.0.1.9 模拟器代码
#### 6.0.1.10

### 6.0.2 B-树
#### 6.0.2.1
#### 6.0.2.2
#### 6.0.2.3
#### 6.0.2.4
#### 6.0.2.5
#### 6.0.2.6
* 命题B
#### 6.0.2.7

### 6.0.3 后缀数组
#### 6.0.3.1
#### 6.0.3.2
#### 6.0.3.3
#### 6.0.3.4
#### 6.0.3.5
#### 6.0.3.6
#### 6.0.3.7
* 算法6.13
#### 6.0.3.8
* 命题D

### 6.0.4 网络流算法
#### 6.0.4.1
#### 6.0.4.2
#### 6.0.4.3
#### 6.0.4.4
* Ford-Fulkerson最大流量算法
#### 6.0.4.5
* 命题E
* 命题F
#### 6.0.4.6
#### 6.0.4.7
* 算法6.14
#### 6.0.4.8
#### 6.0.4.9

### 6.0.5 问题归约
* 定义
#### 6.0.5.1 
#### 6.0.5.2
* 命题I
#### 6.0.5.3
* 命题J
#### 6.0.5.4
* 命题K

### 6.0.6 不可解性
#### 6.0.6.1
#### 6.0.6.2
#### 6.0.6.3
#### 6.0.6.4
#### 6.0.6.5
#### 6.0.6.6
#### 6.0.6.7
#### 6.0.6.8
#### 6.0.6.9
#### 6.0.6.10 Cook-Levin定理
* 命题M
#### 6.0.6.11
#### 6.0.6.12
